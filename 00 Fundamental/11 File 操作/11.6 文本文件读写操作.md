# 文本文件读写操作

## 说明

对文件的读/写操作可以细分为 2 类，分别是以文本形式读写文件和以二进制形式读写文件。

>注意：
>
>1. 文件中存储的数据并没有类型上的分别，统统都是字符。
>2. 以文本形式读/写文件，就是直白地将文件中存储的字符（或字符串）读取出来，以及将目标字符（或字符串）存储在文件中。
>3. 二进制形式读/写文件，操作的对象不再是打开文件就能看到的字符，而是文件底层存储的二进制数据。更详细地讲，当以该形式读取文件时，读取的是该文件底层存储的二进制数据；同样，当将某数据以二进制形式写入到文件中时，写入的也是其对应的二进制数据。

举个例子，假设以文本形式将浮点数 19.625 写入文件，则该文件会直接将 "19.625" 这个字符串存储起来。当双击打开此文件，也可以看到 19.625。值得一提的是，由非字符串数据（比如这里的浮点数 19.625）转换为对应字符串（转化为 "19.625"）的过程，C++ 标准库已经实现好了，不需要操心。

但如果以二进制形式将浮点数 19.625 写入文件，则该文件存储的不再是 "19.625" 这个字符串，而是 19.625 浮点数对应的二进制数据。以 float 类型的 19.625 来说，文件最终存储的数据如下所示： 

```c++
0100 0001 1001 1101 0000 0000 0000 0000
```

> 至于如何得出 float 类型的 19.625 对应的二进制，感兴趣的读者可阅读《[小数在内存中是如何存储的]()》一节。

显然，如果直接将以上二进制数据转换为 float 类型，仍可以得到浮点数 19.625。

但对于文件来说，它只会将存储的二进制数据根据既定的编码格式（如 utf-8、gbk 等）转换为一个个字符。

这也就意味着，如果直接打开此文件，看到的并不会是 19.625，往往是一堆乱码。

## 读写文件方法

> C++ 标准库中，提供了 2 套读写文件的方法组合，分别是：
>
> 1. 使用 `>>` 和 `<<` 读写文件：`适用于以文本形式读写文件`；
> 2. 使用 `read()` 和 `write()` 成员方法读写文件：`适用于以二进制形式读写文件`。

### `>>` 和 `<<` : 读写`文本`文件

通过《[文件流类]()》一节知道了，fstream 或者 ifstream 类负责实现对文件的读取，它们内部都对 >> 输出流运算符做了重载；同样，fstream 和 ofstream 类负责实现对文件的写入，它们的内部也都对 << 输出流运算符做了重载。

所以，**当 fstream 或者 ifstream 类对象打开文件（通常以 ios::in 作为打开模式）之后，就可以直接借助 >> 输入流运算符，`读取`文件中存储的字符（或字符串）；当 fstream 或者 ofstream 类对象打开文件（通常以 ios::out 作为打开模式）后，可以直接借助 << 输出流运算符向文件中`写入`字符（或字符串）**。

```c++
#include <iostream>
#include <fstream>
using namespace std;

int main()
{
    int x,sum=0;
    ifstream srcFile("in.txt", ios::in); //以文本模式打开in.txt备读
    if (!srcFile) { //打开失败
        cout << "error opening source file." << endl;
        return 0;
    }
    ofstream destFile("out.txt", ios::out); //以文本模式打开out.txt备写
    if (!destFile) {
        srcFile.close(); //程序结束前不能忘记关闭以前打开过的文件
        cout << "error opening destination file." << endl;
        return 0;
    }
    //可以像用cin那样用ifstream对象
    while (srcFile >> x) {
        sum += x;
        //可以像 cout 那样使用 ofstream 对象
        destFile << x << " ";
    }
    cout << "sum：" << sum << endl;
    destFile.close();
    srcFile.close();
    return 0;
}
```

>注意:
>
>此程序中分别采用 ios::in 和 ios::out 打开文件，即以文本模式而非二进制模式打开文件。
>
>感兴趣的可在其基础上添加 ios::binary，即以二进制模式打开文件，程序依旧会正常执行。这是因为，以文本模式打开文件和以二进制模式打开文件，并没有很大的区别。

执行此程序之前，必须在和该程序源文件同目录中手动创建一个 in.txt 文件，假设其内部存储的字符串为：

```c++
10 20 30 40 50
```

建立之后，执行程序，其执行结果为：

```c++
sum：150
```

同时在 in.txt 文件同目录下，会生成一个 out.txt 文件，其内部存储的字符和 in.txt 文件完全一样，可自行打开文件查看。

通过分析程序的执行结果不难理解，对于 in.txt 文件中的 "10 20 30 40 50" 字符串，srcFile 对象会依次将 "10"、"20"、"30"、"40"、"50" 读取出来，将它们解析成 int 类型的整数 10、20、30、40、50 并赋值给 x，同时完成和 sum 的加和操作。

同样，对于每次从 in.txt 文件读取并解析出的整形 x，destFile 对象都会原封不动地将其再解析成对应的字符串（如整数 10 解析成字符串 "10"），然后和 " " 空格符一起写入 out.txt 文件。

### `read()` 和 `write()` :读写`二进制`形式文件

相比以文本形式读写文件，以二进制形式读写文件有哪些好处？

举个例子，现在要做一个学籍管理程序，其中一个重要的工作就是记录学生的学号、姓名、年龄等信息。这意味着，需要用一个类来表示学生，如下所示：

```c++
class CStudent
{
    char szName[20];  //假设学生姓名不超过19个字符，以 '\0' 结尾
    char szId[l0];  //假设学号为9位，以 '\0' 结尾
    int age;  //年龄
};
```

前面章节中，学会了如何以文本形式读写文件，如果使用此方式存储学生的信息，则最终的文件中存储的学生信息可能是这个样子：

```txt
Micheal Jackson 110923412 17
Tom Hanks 110923413 18
......
```

要知道，这种存储学生信息的方式不但浪费空间，而且后期不利于查找指定学生的信息（查找效率低下），因为每个学生的信息所占用的字节数不同。

这种情况下，以二进制形式将学生信息存储到文件中，是非常不错的选择，因为以此形式存储学生信息，可以直接把 CStudent 对象写入文件中，这意味着每个学生的信息都只占用 sizeof(CStudent) 个字节。

值得一提的是，要实现以二进制形式读写文件，<< 和 >> 将不再适用，需要使用 C++ 标准库专门提供的 read() 和 write() 成员方法。

其中，read() 方法用于以二进制形式从文件中读取数据；write() 方法用于以二进制形式将数据写入文件。

#### ostream::write() 方法 ：以二进制形式将数据写入文件

ofstream 和 fstream 的 write() 成员方法实际上继承自 ostream 类，其功能是将内存中 buffer 指向的 count 个字节的内容写入文件，基本格式如下：

```c++
ostream & write(char* buffer, int count);
```

- buffer : 用于指定要写入文件的二进制数据的起始位置
- count : 用于指定写入字节的个数

也就是说，**该方法可以被 ostream 类的 cout 对象调用，常用于向屏幕上输出字符串。同时，它还可以被 ofstream 或者 fstream 对象调用，用于将指定个数的二进制数据写入文件。**

同时，**该方法会返回一个作用于该函数的引用形式的对象。**举个例子，obj.write() 方法的返回值就是对 obj 对象的引用.

需要注意的一点是，write() 成员方法向文件中写入若干字节，可是调用 write() 函数时并**没有指定这些字节写入文件中的具体位置**。

事实上，**write() 方法会从`文件写指针`指向的位置将二进制数据写入**。**文件写指针，是 ofstream 或 fstream 对象内部维护的一个变量，文件刚打开时，文件写指针指向的是文件的开头（如果以 ios::app 方式打开，则指向文件末尾），用 write() 方法写入 n 个字节，写指针指向的位置就向后移动 n 个字节**。

- 例子：将学生信息以二进制形式写入文件

```c++
#include <iostream>
#include <fstream>
using namespace std;

class CStudent
{
public:
    char szName[20];
    int age;
};
int main()
{
    CStudent s;
    ofstream outFile("students.dat", ios::out | ios::binary);
    while (cin >> s.szName >> s.age)
        outFile.write((char*)&s, sizeof(s));
    outFile.close();
    return 0;
}
```

输入：

```c++
Tom 60↙
Jack 80↙
Jane 40↙
^Z↙
```

- ↙ : 换行符
- ^Z : 输入 Ctrl + Z 组合键以结束输入

执行程序后，会自动生成一个 students.dat 文件，其内部存有 72 字节的数据，如果用“记事本”打开此文件，可能看到如下乱码：

```txt
Tom 烫烫烫烫烫烫烫烫<   Jack 烫烫烫烫烫烫烫蘌   Jane 烫烫烫烫烫烫烫?
```

值得一提的是，程序中第 13 行指定文件的打开模式为 ios::out | ios::binary，即以二进制写模式打开。

在 Windows平台中，以二进制模式打开文件是非常有必要的，否则可能出错，原因会在《[11.4 文本打开方式和二进制打开方式的区别]()》一节中介绍。

另外，第 15 行将 s 对象写入文件。s 的地址就是要写入文件的内存缓冲区的地址，但是 &s 不是 char * 类型，因此要进行强制类型转换；第 16 行，文件使用完毕一定要关闭，否则程序结束后文件的内容可能不完整。

### istream::read()方法 : 以二进制形式将数据读文件

ifstream 和 fstream 的 read() 方法实际上继承自 istream 类，其功能正好和 write() 方法相反，即从文件中读取 count 个字节的数据。该方法的语法格式如下：

```c++
istream & read(char* buffer, int count);
```

- buffer : 用于指定读取字节的起始位置
- count : 指定读取字节的个数
- 同样，该方法也会返回一个调用该方法的对象的引用。

和 write() 方法类似，**read() 方法从`文件读指针`指向的位置开始读取若干字节**。**文件读指针，可以理解为是 ifstream 或 fstream 对象内部维护的一个变量。文件刚打开时，文件读指针指向文件的开头（如果以 ios::app 方式打开，则指向文件末尾），用 read() 方法读取 n 个字节，读指针指向的位置就向后移动 n 个字节。因此，打开一个文件后连续调用 read() 方法，就能将整个文件的内容读取出来。**

- 例子：将刚刚写入的学生信息以二进制形式读出

```c++
#include <iostream>
#include <fstream>
using namespace std;
class CStudent
{
public:
    char szName[20];
    int age;
};
int main()
{
    CStudent s;       
    ifstream inFile("students.dat",ios::in|ios::binary); //二进制读方式打开
    if(!inFile) {
        cout << "error" <<endl;
        return 0;
    }
    while(inFile.read((char *)&s, sizeof(s))) { //一直读到文件结束
        cout << s.szName << " " << s.age << endl;   
    }
    inFile.close();
    return 0;
}
```

程序的输出结果：

```txt
Tom 60
Jack 80
Jane 40
```

注意，程序中第 18 行直接将 read() 方法作为 while 循环的判断条件，这意味着，read() 方法会一直读取到文件的末尾，将所有字节全部读取完毕，while 循环才会终止。

> 另外，在使用 read() 方法的同时，如果想知道一共成功读取了多少个字节（读到文件尾时，未必能读取 count 个字节），可以在 read() 方法执行后立即调用文件流对象的 gcount() 成员方法，其返回值就是最近一次 read() 方法成功读取的字节数。