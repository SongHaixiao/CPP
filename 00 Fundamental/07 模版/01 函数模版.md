# 模版

## 模板格式

### 参数类型：模板类型参数 

```c++
template <typename 形参名1, typename 形参名2,...>
返回类型 函数名(参数列表)
{ 
    函数体
}
```

- 说明：
  - `typename 可以改为 class`
  - < > 括号中的参数叫 `模板参数`（类似函数形参），编译器根据传入的参数（或实参推导）确定实际的模版参数类型，并实例化

- 例子：

  ```C++
  #include <iostream>
  using namespace std;
  
  class A {};
  
  class B {
  public:
  	bool operator<(const B& rhs) const {
  		//...
  		return true;
  	}
  };
  
  // 参数类型，可以作为返回类型使用
  // 可以值返回（包括指针返回），引用返回
  template<typename T1,typename T2>
  T1* f1(T1& t1, T2& t2) {
  	//...
  	return &t1;
  }
  
  // 调用 myswap 的类型 T 必须支持拷贝构造和赋值
  template<typename T>
  void myswap(T& a, T& b) {
  	T tmp = a;
  	a = b;
  	b = tmp;
  }
  
  // 调用 compare 的类型 T 必须支持 < 操作
  template<typename T>
  bool compare(const T& a, const T& b) {
  	if (a < b)return -1;
  	if (b < a)return -1;
  	return 0;
  }
  
  int main() {
  	
  	A a1, a2;	// A class 类型
  	myswap(a1, a2);
  	myswap<A>(a1, a2);
  	// compare(a1,a2); Erroe : A 没有 < 操作
  
  	B b1, b2;
  	compare(b1, b2);
  
  	int i1 = 1, i2 = 2;
  	f1(i1, i2);		//	T1	T2	都是 int 类型
  	double d1 = 1.0;
  	f1(i1, d1);		//	T1 int,	T2 double
  
  	return 0;
  }
  ```

  

### 参数类型：非类型模板参数

- **非类型的模板参数，在`模板的内部`是`常量`。**

- **只能是`整型`、`对象的指针或引用`，必须能在`编译时确定`。**
  - `局部变量`、`局部对象`**的地址和引用都不行，**
  - `const` **类型的`整形变量`可以，**
  - `全局对象`或`static对象`的`地址`和`引用`可以.
- **`编译时`，编译器通过函数实参来`推断`模版实参，必须显式给出。**

如：

```c++
template<typename T, int N> 
void fun(T t)
{
    //...
}

其中， int N 就是 非类型的模版参数
```

- 例子：

```c++
#include <iostream>
using namespace std;

// 创建静态数组，类型为 T，长度为 N，返回其首地址
template<typename T,int N>
T* f1(const T& t) {
	static T tmp[N];
	for (auto& tt : tmp)tt = t;	// 给每个数组都赋传入的参数的值
	return tmp;
}

// 比较 2 个字符串常量
// 注意： 内联声明 inline 的位置
template<unsigned M, unsigned N>
inline int compare(const char(&p1)[M], const char(&p2)[N]) {
	cout << "M = " << M << ", N = " << N << endl;
	return strcmp(p1, p2);
}

int main() {
	int* p = f1<int, 10>(33);
	for (int i = 0; i < 10; i++)
		cout << *p++ << " ";
	cout << endl;

	int flag = compare("abc", "abcd");
	return 0;
}
```

```c++
// Output

33 33 33 33 33 33 33 33 33 33
M = 4, N = 5
```

## 实例化

当调用一个函数模板时，编译器通常会利用给定的函数实参来推断模板参数，用此实际实参来代替**模板参数**来创建出模板的一个新的“实例”，也就是一个真正可以调用的函数，这个过程称为**实例化**。

![](Resources/00.jpg)

```c++
#include<iostream>
#include<vector>
#include<list>
#include<string>
using namespace std;

// 模仿 std::find，在两个迭代器之间找到匹配的元素，返回迭代器
// T 为迭代器类型，V为元素类型
template<typename T, typename V>
T my_find(const T& b, const T& e, const V& value) {
	T it = b;
	while(it != e && *it != value) 
		++it;
	return it;
}

// 编写 my_begin, my_end，返回数组的头尾指针
template<typename T, unsigned N>
T* my_begin(T(&arr)[N]) {
	cout << "size:" << N << endl;
	return &arr[0];
}

template<typename T, unsigned N>
T* my_end(T(&arr)[N]) {
	return &arr[N - 1];
}

int main() {
	
	vector<int> vec = { 1,4,7,2,5,8 };
	vector<int>::iterator it1 = my_find(vec.begin(), vec.end(), 2);
	if (it1 != vec.end())
		cout << "Find it1 : " << *it1 << endl;
	else
		cout << "vec doesn't find it1." << endl;
	
	cout << "----------------------------------------------" << endl;

	list<string> ls = { "abc","C++","C#" };
	list<string>::iterator it2 = my_find(ls.begin(), ls.end(), "C++");
	if (it2 != ls.end())
		cout << "Find it2 : " << *it2 << endl;
	else
		cout << "list doesn't find it2." << endl;

	cout << "----------------------------------------------" << endl;

	int arr_int[] = { 1,3,5,7,9 };
	int* p_int = my_find(my_begin(arr_int), my_end(arr_int), 5);
	if (p_int != my_end(arr_int))
		cout << "Fid p_int : " << *p_int << endl;
	else
		cout << "arr_int doesn't find p_int." << endl;

	cout << "----------------------------------------------" << endl;

	p_int = my_find(my_begin(arr_int), my_end(arr_int), 6);
	if (p_int != my_end(arr_int))
		cout << "Find p_int : " << *p_int << endl;
	else
		cout << "arr_int doesn't find p_int." << endl;

	cout << "----------------------------------------------" << endl;

	p_int = std::find(std::begin(arr_int), std::end(arr_int), 6);
	if (p_int != std::end(arr_int))
		cout << "Find p_int : " << *p_int << endl;
	else
		cout << "arr_int doesn't find p_int." << endl;

	return 0;

}
```

```c++
// Output

Find it1 : 2
----------------------------------------------
Find it2 : C++
----------------------------------------------
size:5
Fid p_int : 5
----------------------------------------------
size:5
arr_int doesn't find p_int.
----------------------------------------------
arr_int doesn't find p_int.
```

