# STL 概述

## 介绍

标准模板库 STL（Standard Template Library）：一个具有工业强度的，高效的C++程序库，它被容纳于C++标准程序库（C++ Standard Library）中。

STL：包含了`常用的基本数据结构和基本算法`，并提供了`可扩展性`、`可复用性`。

STL：`数据结构`和`算法`的`分离`。

STL：为了具有足够通用性，主要是基于`模板`（泛型程序设计思想）而`不是面向对象`。

C++程序员的神兵利器，通过学习，掌握特性，根据实际的需求选择最合适的。要避免自己再去实现。

主要由六大组件构成：

- `容器（container）`
- `迭代器（iterator）`
- `算法（algorithm）`
- `仿函数（functor）`
- `适配器（adapter）`
- `配置器（allocator）`

## STL 组件

### 1.  容器（container)

各种数据结构，如vector,list,map等，用来存放数据，主要以类模板实现。

### 2. 迭代器（iterator）

“`泛型指针`”，提供访问容器中对象的方法，是容器与算法之间的胶合剂

### 3. 算法（algorithm）
```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class GreaterN {
public:
	GreaterN(int i = 0) : val(i){}
    
	bool operator()(const int& v)const {
	
		if (v > val)
			return true;
	
		else
			return false;
	}
private:
	int val;
};

int main() {
    // vecotr的定义类似如下：_Alloc是空间配置器，默认值是 allocator<_Ty>
    // template<class _Ty, class _Alloc = allocator<_Ty> >
    vector<int>v1;
    vector<int, allocator<int>> v2;

    // 观察：容器、迭代器、算法、仿函数之间的关系
    // 数组也可以看作是一种容器
    int arr[5] = { 1,2,3,4,5 };
    int* it1_beg = begin(arr);	// 相当于 &arr[0]
    int* it1_end = end(arr);	// 相当于 &arr[5]

    // int* 指针，也可以看作是迭代器的一种
    int total = count_if(it1_beg, it1_end, GreaterN(3));
    // GreaterN 是函数对象（仿函数），协助算法指定策略
    // count_if 是算法，统计在两个迭代器之间所有元素满足条件的个数
    cout << total << endl;

    // vector 是一种容器
    vector<int> vec = { 1,2,3,4,5 };
    // vector<int>::iterator 是一种迭代器
    vector<int>::iterator it2_beg = vec.begin();
    vector<int>::iterator it2_end = vec.end();
    int total2 = count_if(it2_beg, it2_end, GreaterN(2)); 

    // 上面三句可以简写为：
    total2 = count_if(vec.begin(), vec.end(), GreaterN(2));
    cout << total2 << endl;

    return 0;
}
```

是用来操作容器中的数据的函数模板。函数本身与他们操作的`数据的结构和类型无关`，因此他们可以在从简单数组到复杂容器的任何数据结构上使用。

### 4. 仿函数（functor）

行为类似函数（函数对象），可作为算法的某种策略。

### 5. 适配器（adapter）

一种用来修饰容器、迭代器、仿函数接口的东西。如stack是一种容器适配器。

### 6. 配置器（allocator）

负责空间配置和管理。是一个实现了动态空间配置、管理、释放的类模板。

![](Resources/00.jpg)

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class GreaterN {
public:
	GreaterN(int i = 0) : val(i){}

	bool operator()(const int& v)const {
		
		if (v > val)
			return true;
		
		else
			return false;
	}

private:
	int val;
};

int main() {
	
	// vecotr的定义类似如下：_Alloc是空间配置器，默认值是 allocator<_Ty>
	// template<class _Ty, class _Alloc = allocator<_Ty> >
	vector<int>v1;
	vector<int, allocator<int>> v2;

	// 观察：容器、迭代器、算法、仿函数之间的关系
	// 数组也可以看作是一种容器
	int arr[5] = { 1,2,3,4,5 };
	int* it1_beg = begin(arr);	// 相当于 &arr[0]
	int* it1_end = end(arr);	// 相当于 &arr[5]
	
	// int* 指针，也可以看作是迭代器的一种
	int total = count_if(it1_beg, it1_end, GreaterN(3));
	// GreaterN 是函数对象（仿函数），协助算法指定策略
	// count_if 是算法，统计在两个迭代器之间所有元素满足条件的个数
	cout << total << endl;

	// vector 是一种容器
	vector<int> vec = { 1,2,3,4,5 };
	// vector<int>::iterator 是一种迭代器
	vector<int>::iterator it2_beg = vec.begin();
	vector<int>::iterator it2_end = vec.end();
	int total2 = count_if(it2_beg, it2_end, GreaterN(2)); 

	// 上面三句可以简写为：
	total2 = count_if(vec.begin(), vec.end(), GreaterN(2));
	cout << total2 << endl;

	return 0;
}
```

```c++
// Output

2
3
```

